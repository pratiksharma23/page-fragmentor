{"mappings":"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","sources":["./src/index.js","./src/get_overflowing_range.js","./src/generators/break_point_generator.js","./src/generators/node_generator.js","./src/caches/rect_filter_cache.js","./src/break_points/base_break_point.js","./src/generators/line_box_generator.js","./src/break_points/inline_break_point.js","./src/break_points/sibling_break_point.js","./src/caches/node_rule_cache.js","./src/parse_page_size.js","./src/extract.js","./src/uuid.js","./src/extractors/table_extractor.js","./src/extractors/list_extractor.js","./src/auto.js"],"sourcesContent":["import { getOverflowingRange } from './get_overflowing_range';\nimport { parsePageSize } from './parse_page_size';\nimport { extract } from './extract';\n\nfunction newPage({ footer, header, pageNumber }) {\n  const page = document.createElement('div');\n  page.classList.add('page');\n  page.setAttribute('role', 'region');\n  page.setAttribute('aria-label', `Page ${pageNumber}`);\n  page.setAttribute('data-page-number', pageNumber);\n  page.style.setProperty('--page-number', pageNumber);\n  document.body.appendChild(page);\n  const pageInner = document.createElement('div');\n  pageInner.classList.add('page-inner');\n  page.appendChild(pageInner);\n\n  if (header) {\n    const pageHeader = document.createElement('div');\n    pageHeader.classList.add('page-header');\n    pageInner.appendChild(pageHeader);\n    pageHeader.appendChild(header.cloneNode(true));\n  }\n\n  const pageContent = document.createElement('div');\n  pageContent.classList.add('page-content');\n  pageInner.appendChild(pageContent);\n\n  if (footer) {\n    const pageFooter = document.createElement('div');\n    pageFooter.classList.add('page-footer');\n    pageInner.appendChild(pageFooter);\n    pageFooter.appendChild(footer.cloneNode(true));\n  }\n  return pageContent;\n}\n\nfunction childrenToFragment(node) {\n  const fragment = document.createDocumentFragment();\n  Array.from(node.childNodes).forEach((child) => {\n    fragment.appendChild(child);\n  });\n  return fragment;\n}\n\nfunction getStartingContent() {\n  const main = document.querySelector('body > main');\n  const content = childrenToFragment(main || document.body);\n  main?.remove();\n  return content;\n}\n\nfunction extractSelector(selector) {\n  const node = document.querySelector(selector);\n  if (node) {\n    return childrenToFragment(node);\n  }\n  return null;\n}\n\nfunction emptyFragment(node) {\n  return !node.hasChildNodes()\n    || (node.childNodes.length === 1\n      && node.firstChild.nodeType === Node.TEXT_NODE\n      && !node.firstChild.data.trim()\n    );\n}\n\nfunction emptyRange(range) {\n  if (!range || range.collapsed || emptyFragment(range.cloneContents())) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Move the content into pages\n */\nexport function createPages() {\n  const size = parsePageSize(window.getComputedStyle(document.body).getPropertyValue('--page-size'));\n  document.documentElement.style.setProperty('--page-width', size[0]);\n  document.documentElement.style.setProperty('--page-height', size[1]);\n\n  const header = extractSelector('body > header');\n  const footer = extractSelector('body > footer');\n  let content = getStartingContent();\n  document.body.innerHTML = '';\n  let pageCount = 0;\n  let forceExtraPage = false;\n\n  while (forceExtraPage || !pageCount || (content && !emptyFragment(content))) {\n    pageCount += 1;\n\n    const page = newPage({ footer, header, pageNumber: pageCount });\n    if (content) {\n      page.appendChild(content);\n    }\n\n    const outerPage = page.closest('.page');\n    outerPage.dispatchEvent(new CustomEvent('create-page', { bubbles: true }));\n\n    let range = getOverflowingRange(page);\n\n    if (emptyRange(range)) {\n      // Last page\n      outerPage.dataset.lastPage = 'true';\n\n      // Recalculate overflow\n      range = getOverflowingRange(page);\n\n      if (forceExtraPage) {\n        break;\n      }\n\n      // Adding lastPage has created additional overflow\n      // Need to force an extra page for headers and footers\n      if (!emptyRange(range)) {\n        delete outerPage.dataset.lastPage;\n        forceExtraPage = true;\n        range = getOverflowingRange(page);\n      }\n    }\n\n    if (range) {\n      outerPage.dispatchEvent(new CustomEvent('before-fragmentation', { detail: range, bubbles: true }));\n      content = extract(range);\n      outerPage.dispatchEvent(new CustomEvent('after-fragmentation', { detail: content, bubbles: true }));\n    } else {\n      content = null;\n    }\n  }\n\n  document.body.style.setProperty('--page-count', pageCount);\n  document.body.dataset.pageCount = pageCount;\n  document.body.dispatchEvent(new CustomEvent('fragmentation-finished', { bubbles: true }));\n}\n","import { breakPointGenerator } from './generators/break_point_generator';\n\n/**\n * Returns the range overflowing an element\n */\nexport function getOverflowingRange(root) {\n  const breakPointIterator = breakPointGenerator(root);\n\n  const breakPoints = [];\n  let overflowing = false;\n  for (const breakPoint of breakPointIterator) {\n    // Always use the first forced breakpoint\n    if (!overflowing && breakPoint.force && !breakPoint.overflowing) {\n      const range = breakPoint.range();\n      if (range) {\n        return range;\n      }\n    }\n\n    if (!overflowing && breakPoint.overflowing) {\n      overflowing = true;\n\n      // Find the last useable breakpoint\n      // Retrying with relaxed rules\n      // https://www.w3.org/TR/css-break-3/#unforced-breaks\n      for (const disableRules of [[], [3], [1, 3], [1, 2, 3], [1, 2, 3, 4]]) {\n        for (const previousBreakPoint of breakPoints) {\n          const range = previousBreakPoint.range(disableRules);\n          if (range) {\n            return range;\n          }\n        }\n      }\n    }\n\n    if (!overflowing) {\n      breakPoints.unshift(breakPoint);\n    } else {\n      // No valid break point found.  We are overflowing\n      // Use the next break point with any result\n      const range = breakPoint.range([1, 2, 3, 4]);\n      if (range) {\n        return range;\n      }\n    }\n  }\n\n  return null;\n}\n","import { nodeGenerator } from './node_generator';\nimport { RectFilter } from '../caches/rect_filter_cache';\nimport { BaseBreakPoint } from '../break_points/base_break_point';\nimport { InlineBreakPoint } from '../break_points/inline_break_point';\nimport { SiblingBreakPoint } from '../break_points/sibling_break_point';\nimport { NodeRules } from '../caches/node_rule_cache';\n\n/**\n * Yields permissible break points\n *\n * Based on CSS fragmentation Module level 3\n * https://www.w3.org/TR/css-break-3/\n */\nexport function* breakPointGenerator(root) {\n  const rectFilter = new RectFilter();\n  const nodeIterator = nodeGenerator(root, rectFilter);\n  const nodeRules = new NodeRules();\n\n  let currentBreakPoint = new SiblingBreakPoint({ root, nodeRules, rectFilter });\n  let lastType;\n\n  for (const [type, node] of nodeIterator) {\n    switch (type) {\n      case 'enter': {\n        if (lastType === 'inline') {\n          const lastBreakPoint = currentBreakPoint;\n          yield currentBreakPoint;\n\n          currentBreakPoint = new SiblingBreakPoint({ root, nodeRules, rectFilter });\n          currentBreakPoint.trailingNodes.push(lastBreakPoint.lastNode);\n        }\n        currentBreakPoint.leadingNodes.push(node);\n        break;\n      }\n\n      case 'inline': {\n        if (lastType === 'exit') {\n          currentBreakPoint.leadingNodes.push(node);\n        }\n        if (lastType !== type) {\n          yield currentBreakPoint;\n          currentBreakPoint = new InlineBreakPoint({ root, nodeRules, rectFilter });\n        }\n        currentBreakPoint.nodes.push(node);\n        break;\n      }\n\n      case 'exit': {\n        if (lastType !== type) {\n          yield currentBreakPoint;\n          currentBreakPoint = new SiblingBreakPoint({ root, nodeRules, rectFilter });\n        }\n        currentBreakPoint.trailingNodes.push(node);\n        break;\n      }\n\n      default:\n        throw new Error(`unexpected node type ${type}`);\n    }\n\n    lastType = type;\n  }\n\n  yield currentBreakPoint;\n\n  // If the last node is a text node and we are overflowing we may need to force a breakpoint\n  currentBreakPoint = new BaseBreakPoint({ root, nodeRules, rectFilter });\n  yield currentBreakPoint;\n}\n","function* iterateLevel(walker, inline = false) {\n  do {\n    const { currentNode } = walker;\n\n    if (currentNode.nodeType === Node.TEXT_NODE) {\n      yield ['inline', currentNode];\n      continue;\n    }\n\n    // Inline can only be broken across text nodes\n    const isInline = inline || window.getComputedStyle(currentNode).display.includes('inline');\n\n    yield [isInline ? 'inline' : 'enter', currentNode];\n\n    if (!currentNode.matches('picture,video,canvas,object,audio,embed,iframe,svg,math') && walker.firstChild()) {\n      yield* iterateLevel(walker, isInline);\n      walker.parentNode();\n    }\n\n    if (!isInline) {\n      yield ['exit', currentNode];\n    }\n  } while (walker.nextSibling());\n}\n\nconst types = NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT;\n\n/**\n * SAX parser style DOM iterator\n *\n * Yields ['enter', node], ['text', node] and ['exit', node] values for a DOM structure\n */\nexport function* nodeGenerator(root, nodeFilter) {\n  const walker = document.createTreeWalker(root, types, nodeFilter);\n  if (!walker.nextNode()) {\n    return;\n  }\n  yield* iterateLevel(walker);\n}\n","export class RectFilter extends Map {\n  get(node) {\n    if (this.has(node)) {\n      return super.get(node);\n    }\n    let rect;\n    if (node.nodeType === Node.TEXT_NODE) {\n      const range = new Range();\n      range.selectNode(node);\n      rect = range.getBoundingClientRect();\n    } else {\n      rect = node.getBoundingClientRect();\n    }\n    this.set(node, rect);\n    return rect;\n  }\n\n  acceptNode(node) {\n    const rect = this.get(node);\n    if (rect.height === 0) {\n      return NodeFilter.FILTER_REJECT;\n    }\n    return NodeFilter.FILTER_ACCEPT;\n  }\n}\n","/**\n * Represents a possible break point\n *\n * The spec has three types of breakpoints:\n * - Class A: between siblings\n * - Class B: between line-boxes\n * - Class C: between a block and child content edges\n *\n * Only class A and B are supported\n */\nexport class BaseBreakPoint {\n  constructor({ rectFilter, nodeRules, root }) {\n    this.rectFilter = rectFilter;\n    this.nodeRules = nodeRules;\n    this.root = root;\n  }\n\n  // A forced breakpoint\n  get force() {\n    return false;\n  }\n\n  // Breakpoint is set to avoid\n  get avoid() {\n    return false;\n  }\n\n  // Breakpoint is overflowing content area\n  get overflowing() {\n    return this.root.scrollHeight > this.root.clientHeight;\n  }\n\n  // Return range of overflowing content\n  range() {\n    return null;\n  }\n\n  // Internals\n  // ---------\n\n  get rootRect() {\n    return this.rectFilter.get(this.root);\n  }\n}\n","/**\n * Yields each line box as a range\n *\n * The selection API is the only API that gives any access to lineboxes\n *\n * Calculating though measuring ranges is slow and cannot cope\n * with different writing directions or unusual margins are paddings.\n */\nexport function* lineBoxGenerator(nodes) {\n  const selection = window.getSelection();\n\n  const firstText = nodes.find((node) => node.nodeType === Node.TEXT_NODE);\n  const lastText = [...nodes].reverse().find((node) => node.nodeType === Node.TEXT_NODE);\n\n  if (!firstText) {\n    return;\n  }\n\n  const textRange = new Range();\n  textRange.setStart(firstText, 0);\n  textRange.setEnd(lastText, lastText.data.length);\n\n  selection.empty();\n  selection.addRange(textRange);\n  selection.collapseToStart();\n\n  let lastRange = null;\n\n  while (true) {\n    selection.modify('extend', 'forward', 'line');\n\n    const lineRange = selection.getRangeAt(0);\n\n    if (lastRange) {\n      lineRange.setStart(lastRange.endContainer, lastRange.endOffset);\n    }\n\n    if (lineRange.collapsed) {\n      return;\n    }\n\n    // Chrome gets stuck at full width inline blocks\n    // So jump end to the start of the next text node\n    if (lineRange.endOffset === 0 && lineRange.endContainer.nodeType === Node.ELEMENT_NODE) {\n      const node = nodes.find((item) => (\n        item.nodeType === Node.TEXT_NODE\n          && item !== lineRange.endContainer\n          && lineRange.comparePoint(item, 0) === 1\n      ));\n      if (node) {\n        lineRange.setEndBefore(node);\n      }\n    }\n\n    if (textRange.compareBoundaryPoints(Range.END_TO_END, lineRange) === -1) {\n      lineRange.setEnd(textRange.endContainer, textRange.endOffset);\n    }\n\n    // Stuck protection\n    if (lastRange && lineRange.compareBoundaryPoints(Range.START_TO_START, lastRange) === 0) {\n      break;\n    }\n\n    yield lineRange;\n\n    // At end of the text range\n    if (textRange.compareBoundaryPoints(Range.END_TO_END, lineRange) === 0) {\n      break;\n    }\n\n    lastRange = lineRange.cloneRange();\n  }\n}\n","import { BaseBreakPoint } from './base_break_point';\nimport { lineBoxGenerator } from '../generators/line_box_generator';\n\nfunction calculateBottomSpace(container) {\n  const style = window.getComputedStyle(container);\n  const size = (parseFloat(style.paddingBottom) || 0)\n    + (parseFloat(style.borderBottomWidth) || 0)\n    + (parseFloat(style.marginBottom) || 0);\n\n  return Math.ceil(Math.max(size, 0));\n}\n\n/**\n * Represents a class B breakpoint\n */\nexport class InlineBreakPoint extends BaseBreakPoint {\n  constructor(...args) {\n    super(...args);\n    this.nodes = [];\n  }\n\n  get overflowing() {\n    const rect = this.rectFilter.get(this.firstNode);\n    return rect.top > this.rootRect.bottom;\n  }\n\n  range(disableBreakRules = []) {\n    if (!disableBreakRules.includes(4) && this.containerRules.breakInsideAvoid) {\n      return null;\n    }\n\n    const lineBoxRange = this.findLineBoxRange(disableBreakRules.includes(3));\n    const overflowingNodeRange = this.findFirstOverflowingNodeRange();\n\n    let overflowing = lineBoxRange || overflowingNodeRange;\n\n    if (lineBoxRange && overflowingNodeRange) {\n      if (lineBoxRange.compareBoundaryPoints(Range.START_TO_START, overflowingNodeRange) === 1) {\n        overflowing = lineBoxRange;\n      } else {\n        overflowing = overflowingNodeRange;\n      }\n    }\n\n    if (!overflowing) {\n      return null;\n    }\n\n    const range = new Range();\n    range.setStart(overflowing.startContainer, overflowing.startOffset);\n    range.setEndAfter(this.root.lastChild);\n    return range;\n  }\n\n  // Internals\n  // ---------\n\n  // Find the first overflowing linebox obeying widow and orphan rules\n  findLineBoxRange(relaxWidowsAndOrphans) {\n    let { widows, orphans } = this.containerRules;\n\n    widows = widows || 2;\n    orphans = orphans || 2;\n\n    if (relaxWidowsAndOrphans) {\n      widows = 1;\n      orphans = 1;\n    }\n\n    let lineBoxes = [];\n    let overflow = false;\n    let overflowIndex;\n\n    for (const lineBox of lineBoxGenerator(this.nodes)) {\n      if (!overflow) {\n        const rect = lineBox.getBoundingClientRect();\n        if (rect.bottom > (this.rootRect.bottom - this.bottomSpace)) {\n          overflow = lineBox;\n          overflowIndex = lineBoxes.length;\n        }\n      }\n      if (overflow && lineBoxes.length > overflowIndex + widows - 1) {\n        break;\n      }\n      lineBoxes.push(lineBox);\n    }\n\n    if (overflowIndex !== undefined) {\n      if (overflowIndex < orphans) {\n        // Insufficient orphans\n        return null;\n      }\n\n      lineBoxes = lineBoxes.slice(orphans);\n    }\n\n    return lineBoxes[lineBoxes.length - widows] || null;\n  }\n\n  // Find the first overflowing element\n  // If it is not a text node, and not the first node return it\n  findFirstOverflowingNodeRange() {\n    const foundNode = this.nodes.find((node) => {\n      const rect = this.rectFilter.get(node);\n      return rect.bottom > (this.rootRect.bottom - this.bottomSpace);\n    });\n\n    if (!foundNode || foundNode.nodeType === Node.TEXT_NODE || foundNode === this.firstNode) {\n      return null;\n    }\n    const range = new Range();\n    range.setStartBefore(foundNode);\n    return range;\n  }\n\n  get container() {\n    if (this._container) {\n      return this._container;\n    }\n    const range = new Range();\n    range.setStartBefore(this.firstNode);\n    range.setEndAfter(this.lastNode);\n    let container = range.commonAncestorContainer;\n    if (container.nodeType === Node.TEXT_NODE) {\n      container = container.parentNode;\n    }\n    this._container = container;\n    return container;\n  }\n\n  get bottomSpace() {\n    return (this._bottomSpace ??= calculateBottomSpace(this.container));\n  }\n\n  get containerRules() {\n    return (this._containerRules ??= this.nodeRules.get(this.container));\n  }\n\n  get firstNode() {\n    return this.nodes[0];\n  }\n\n  get lastNode() {\n    return this.nodes[this.nodes.length - 1];\n  }\n}\n","import { BaseBreakPoint } from './base_break_point';\n\n/**\n * Represents a class A breakpoint\n */\nexport class SiblingBreakPoint extends BaseBreakPoint {\n  constructor(...args) {\n    super(...args);\n    this.leadingNodes = [];\n    this.trailingNodes = [];\n  }\n\n  get force() {\n    return (this._force ??= this.leadingNodes.some((node) => this.nodeRules.get(node).breakBefore === 'page')\n      || this.trailingNodes.some((node) => this.nodeRules.get(node).breakAfter === 'page'));\n  }\n\n  get overflowing() {\n    return this.leadingNodes.some(this.hasLeadingOverflow, this)\n      || this.trailingNodes.some(this.hasTrailingOverflow, this);\n  }\n\n  get avoid() {\n    return this.leadingNodes.some((node) => ['avoid', 'avoid-page'].includes(this.nodeRules.get(node).breakBefore))\n      || this.trailingNodes.some((node) => ['avoid', 'avoid-page'].includes(this.nodeRules.get(node).breakAfter));\n  }\n\n  range(disableBreakRules = []) {\n    const { node, force, avoid } = this;\n\n    if (!node || (node === Node.ELEMENT_NODE && node.matches('td,th'))) {\n      return null;\n    }\n    if (!force\n      && !disableBreakRules.includes(2)\n      && this.nodeRules.get(node).breakInsideParentAvoid\n    ) {\n      return null;\n    }\n    if (!force && !disableBreakRules.includes(1) && avoid) {\n      return null;\n    }\n\n    const range = new Range();\n    range.setStartAfter(node);\n    range.setEndAfter(this.root.lastChild);\n    return range;\n  }\n\n  // Internals\n  // ---------\n\n  get node() {\n    return this.trailingNodes[this.trailingNodes.length - 1];\n  }\n\n  hasLeadingOverflow(node) {\n    const rect = this.rectFilter.get(node);\n    return rect.top > this.rootRect.bottom;\n  }\n\n  hasTrailingOverflow(node) {\n    const rect = this.rectFilter.get(node);\n    const style = node.nodeType === Node.ELEMENT_NODE ? window.getComputedStyle(node) : {};\n    const bottom = Math.ceil(rect.bottom + (parseFloat(style.marginBottom) || 0));\n    return bottom > Math.floor(this.rootRect.bottom);\n  }\n}\n","export class NodeRules extends Map {\n  get(node) {\n    if (node instanceof Text) {\n      return this.get(node.parentNode);\n    }\n    if (!(node instanceof Element)) {\n      return {\n        breakInsideAvoid: false,\n        breakInsideParentAvoid: false,\n        breakAfter: 'auto',\n        breakBefore: 'auto',\n        orphans: 2,\n        widows: 2,\n      };\n    }\n    if (this.has(node)) {\n      return super.get(node);\n    }\n    const rule = this.findInheritedRule(node);\n    this.set(node, rule);\n    return rule;\n  }\n\n  findInheritedRule(node) {\n    const parentRule = this.get(node.parentNode);\n    const styles = window.getComputedStyle(node);\n    return {\n      breakInsideAvoid: ['avoid', 'avoid-page'].includes(styles.getPropertyValue('break-inside')) || parentRule.breakInsideAvoid,\n      breakInsideParentAvoid: parentRule.breakInsideAvoid,\n      breakAfter: styles.getPropertyValue('break-after'),\n      breakBefore: styles.getPropertyValue('break-before'),\n      orphans: parseInt(styles.getPropertyValue('--orphans') || styles.getPropertyValue('orphans') || 2, 10),\n      widows: parseInt(styles.getPropertyValue('--widows') || styles.getPropertyValue('widows') || 2, 10),\n    };\n  }\n}\n","const rNamedSize = /^(A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger|landscape|portrait)(?:\\s+(landscape|portrait)$)?/;\n\nconst SIZES = {\n  A5: ['148mm', '210mm'],\n  A4: ['210mm', '297mm'],\n  A3: ['297mm', '420mm'],\n  B5: ['176mm', '250mm'],\n  B4: ['250mm', '353mm'],\n  'JIS-B5': ['182mm', '257mm'],\n  'JIS-B4': ['257mm', '364mm'],\n  letter: ['8.5in', '11in'],\n  legal: ['8.5in', '14in'],\n  ledger: ['11in', '17in'],\n};\n\n// https://www.w3.org/TR/css-page-3/#page-size-prop\nexport function parsePageSize(size) {\n  size = size.trim(); // eslint-disable-line no-param-reassign\n  if (!size || size === 'auto') {\n    return SIZES.A4;\n  }\n  const match = rNamedSize.exec(size);\n  if (!match) {\n    const parts = size.split(/\\s+/);\n    if (parts.length === 1) {\n      parts.push(parts[0]);\n    }\n    return parts;\n  }\n  let [, namedSize, orientation] = match;\n  if (['portrait', 'landscape'].includes(namedSize)) {\n    orientation = namedSize;\n    namedSize = 'A4';\n  }\n  const matchedSize = [...SIZES[namedSize]];\n  if (orientation === 'landscape') {\n    matchedSize.reverse();\n  }\n  return matchedSize;\n}\n","import { TableExtractor } from './extractors/table_extractor';\nimport { ListExtractor } from './extractors/list_extractor';\n\n/**\n * Extract a range\n * If the range is part of a table\n *   - Clone headers\n *   - Switch the table to a fixed layout\n */\nexport function extract(range) {\n  const extractors = [new TableExtractor(), new ListExtractor()];\n  extractors.forEach((extractor) => extractor.before(range));\n  const contents = range.extractContents();\n  extractors.forEach((extractor) => extractor.after(contents));\n  return contents;\n}\n","/* eslint-disable no-bitwise, no-mixed-operators */\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n","import { uuid } from '../uuid';\n\nfunction fixTable(table) {\n  // If the table already has cols, don't add new ones\n  if (!table.querySelector('col')) {\n    const columns = [...table.rows[0].cells].reduce((total, cell) => total + cell.colSpan, 0);\n\n    for (let i = 0; i < columns; i += 1) {\n      const col = document.createElement('col');\n      col.dataset.fragmenationCol = true;\n      table.prepend(col);\n    }\n  }\n\n  // Fix the widths of the columns\n  [...table.querySelectorAll('col')].forEach((col) => {\n    const rect = col.getBoundingClientRect();\n    // eslint-disable-next-line no-param-reassign\n    col.style.width = `${rect.width}px`;\n  });\n}\n\nfunction findAndMarkTables(range) {\n  const tables = [];\n  let cursor = range.startContainer;\n  if (cursor.nodeType === Node.TEXT_NODE) {\n    cursor = cursor.parentNode;\n  }\n  cursor = cursor.closest('table');\n  while (cursor) {\n    cursor.dataset.fragmentationUuid = uuid();\n    fixTable(cursor);\n    tables.push(cursor);\n    cursor = cursor.parentNode.closest('table');\n  }\n  return tables;\n}\n\nexport class TableExtractor {\n  before(range) {\n    this.tables = findAndMarkTables(range);\n  }\n\n  after(fragment) {\n    this.tables.forEach((table) => {\n      const newTable = fragment.querySelector(`table[data-fragmentation-uuid=\"${table.dataset.fragmentationUuid}\"]`);\n      if (!newTable) {\n        return;\n      }\n      // Remove fixed widths\n      [...table.querySelectorAll('col[data-fragmentation-col]')].forEach((col) => col.remove());\n      // Add in thead\n      if (!newTable.tHead && table.tHead) {\n        newTable.tHead = table.tHead.cloneNode(true);\n      }\n      // Remove duplicated uuid\n      delete newTable.dataset.fragmentationUuid;\n    });\n  }\n}\n","import { uuid } from '../uuid';\n\nfunction visibleListItem(node) {\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return false;\n  }\n\n  return node.matches('li') && node.getBoundingClientRect().height > 0;\n}\n\nfunction findAndMarkLists(range) {\n  const lists = [];\n  let cursor = range.startContainer;\n  if (cursor.nodeType === Node.TEXT_NODE) {\n    cursor = cursor.parentNode;\n  }\n  cursor = cursor.closest('ol');\n  while (cursor) {\n    cursor.dataset.fragmentationUuid = uuid();\n    lists.push(cursor);\n    if (cursor.reversed) {\n      const items = [...cursor.childNodes].filter(visibleListItem).length;\n      cursor.start = items;\n    }\n    cursor = cursor.parentNode.closest('ol');\n  }\n  return lists;\n}\n\nexport class ListExtractor {\n  before(range) {\n    this.lists = findAndMarkLists(range);\n  }\n\n  after(fragment) {\n    this.lists.forEach((list) => {\n      const items = [...list.childNodes].filter(visibleListItem).length;\n      const newList = fragment.querySelector(`ol[data-fragmentation-uuid=\"${list.dataset.fragmentationUuid}\"]`);\n      if (newList) {\n        if (newList.reversed) {\n          newList.start = list.start - items;\n        } else {\n          newList.start = list.start + items;\n        }\n        delete newList.dataset.fragmentationUuid;\n      }\n    });\n  }\n}\n","import { createPages } from './index';\n\nwindow.addEventListener('DOMContentLoaded', async () => {\n  document.body.setAttribute('aria-busy', 'true');\n});\n\n// Wait for everything to load\nwindow.addEventListener('load', async () => {\n  // Fonts aren't included in load 🤷\n  await document.fonts.ready;\n  // Fragment the pages\n  createPages();\n\n  document.body.setAttribute('aria-busy', 'false');\n\n  // Line boxes are found using the selection api\n  // Clear any selection and return to top\n  window.getSelection().empty();\n  window.scrollTo(0, 0);\n});\n"],"names":["size","$9de2edf9567a287dc021282cc88115a7$exports","parsePageSize","window","getComputedStyle","document","body","getPropertyValue","documentElement","style","setProperty","header","extractSelector","footer","content","main","querySelector","childrenToFragment","remove","getStartingContent","innerHTML","pageCount","forceExtraPage","emptyFragment","page","newPage","pageNumber","appendChild","outerPage","closest","dispatchEvent","CustomEvent","bubbles","range","$b701afed18d4af64204ab13782c9ce48$exports","getOverflowingRange","emptyRange","dataset","lastPage","detail","$8f71022b41ea134c4296058b3e092b1c$exports","extract","root","breakPointIterator","$dad4f9540dd8c7fa9e8ac2c94f3329ff$exports","breakPointGenerator","breakPoints","overflowing","breakPoint","force","disableRules","previousBreakPoint","unshift","rectFilter","RectFilter","nodeIterator","$566c8abb06db1d4ea01e374fffeeed51$exports","nodeGenerator","nodeRules","NodeRules","lastType","currentBreakPoint","SiblingBreakPoint","type","node","lastBreakPoint","trailingNodes","push","lastNode","leadingNodes","InlineBreakPoint","nodes","Error","BaseBreakPoint","nodeFilter","walker","createTreeWalker","types","nextNode","iterateLevel","inline","currentNode","nodeType","Node","TEXT_NODE","isInline","display","includes","matches","firstChild","parentNode","nextSibling","NodeFilter","SHOW_ELEMENT","SHOW_TEXT","Map","get","this","has","super","rect","Range","selectNode","getBoundingClientRect","set","acceptNode","height","FILTER_REJECT","FILTER_ACCEPT","constructor","avoid","scrollHeight","clientHeight","rootRect","selection","getSelection","firstText","find","lastText","reverse","textRange","setStart","setEnd","data","length","empty","addRange","collapseToStart","lastRange","modify","lineRange","getRangeAt","endContainer","endOffset","collapsed","ELEMENT_NODE","item","comparePoint","setEndBefore","compareBoundaryPoints","END_TO_END","START_TO_START","cloneRange","args","firstNode","top","bottom","disableBreakRules","containerRules","breakInsideAvoid","lineBoxRange","findLineBoxRange","overflowingNodeRange","findFirstOverflowingNodeRange","startContainer","startOffset","setEndAfter","lastChild","relaxWidowsAndOrphans","widows","orphans","overflowIndex","lineBoxes","overflow","lineBox","$cce981636e58dad7a7b88983e1655bef$exports","lineBoxGenerator","bottomSpace","undefined","slice","foundNode","setStartBefore","container","_container","commonAncestorContainer","_this$_bottomSpace","_bottomSpace","parseFloat","paddingBottom","borderBottomWidth","marginBottom","Math","ceil","max","calculateBottomSpace","_this$_containerRules","_containerRules","_this$_force","_force","some","breakBefore","breakAfter","hasLeadingOverflow","hasTrailingOverflow","breakInsideParentAvoid","setStartAfter","floor","Text","Element","rule","findInheritedRule","parentRule","styles","parseInt","trim","SIZES","A4","match","rNamedSize","exec","parts","split","namedSize","orientation","matchedSize","A5","A3","B5","B4","JIS-B5","JIS-B4","letter","legal","ledger","extractors","TableExtractor","ListExtractor","forEach","extractor","before","contents","extractContents","after","replace","c","r","random","toString","fixTable","table","columns","rows","cells","reduce","total","cell","colSpan","i","col","createElement","fragmenationCol","prepend","querySelectorAll","width","tables","cursor","fragmentationUuid","$0001cb9ebf25ca3c24ad7e2dcda20152$exports","uuid","findAndMarkTables","fragment","newTable","tHead","cloneNode","visibleListItem","classList","add","setAttribute","pageInner","pageHeader","pageContent","pageFooter","createDocumentFragment","Array","from","childNodes","child","selector","hasChildNodes","cloneContents","lists","reversed","items","filter","start","findAndMarkLists","list","newList","addEventListener","async","fonts","ready","$f7dd019967b48e7c9c8befdf791fed14$exports","createPages","scrollTo"],"version":3,"file":"auto.js.map"}